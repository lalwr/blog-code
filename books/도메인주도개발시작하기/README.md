# 도메인 주도 개발 시작하기

[책](https://book.naver.com/bookdb/book_detail.nhn?bid=22291738)

## 1. 도메인

- 도메인은 여러 하위 도메인으로 구성된다
- 도메인마다 고정된 하위 도메인이 존재하는 것은 아니다 .
- 코딩에 앞서 요구사힝을 올바르게 이해하는 것이 중요하다. 요구사항을 제대로 이해하지 않으면 쓸모없거나 유용함이 떨어지는 시스템을 만들기 때문이다

### 모델 패턴

- 사용자 인터페이스 또는 표현
- 사용자의 요청을 처리하고 사용자에게 정보를 보여준다 . 여기서 사용자는
  소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다．
- 응용
  - 사용자가 요청한 기능을 실행한다 . 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다．
- 도메인 
  - 시스템이 제공할 도메인 규칙을 구현한다．
- 인프라스트럭쳐 
  - 데이터베이스나 메시징 시스템과 같은 외부 사스템과의 연동을 처리한다

### 도메임 모델 도출

도메인을모델링할 때 기본이 되는 작업은 모델을구성하는 핵심 구성요소 , 규칙 , 기능을 찾는
것이다 . 이 과정은 요구사항에서 출발한다

### 엔티티와 밸류

엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 이 둘의
차이를 명확하게 이해하는 것은 도메인을 구현하는 데 있어 중요하다．

엔티티의 가장 큰 특징은 식별자를 가진다는 것이다 . 식별자는 엔티티 객쳬마다 고유해서 각
엔티티는 서로 다른 식별자를 갖는다

밸류 타입은 코드의 의미룰 더 잘 이해할 수 있도록 한다．

데이터 변경 기능을 제공하지 않는 타입을 불변이라고 표현한다. 밸류 타입을 불변으로 구현하는 여러 이유가 있는데 가장 중요한 이유는 안전한 코드름 작성할 수 있
다는 데 있다

#### 도메인 모델에 set 메서드 넣지 않기

도메인 객쳬가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어
야한다 . 즉 생성자를통해 필요한 데이터를모두 받아야 한다.

set 메서드는 앞서 언급한 set 메서드와 중요한 차이점이 있는데 그것은 바로 접근
범위가 private이라는 점이다 . 이 코드에서 set 메서드는 클래스 내부에서 데이터를 변경할 목
적으로 사용된다 . private이기 때문에 외부에서 데이터를 변경할 목적으로 set 메서드를 사용
할 수 없다．

불변 밸류 타입을 사용하면 자연스럽게 밸류 타입에는 set 메서드를 구현하지 않는다 . set 메
서드를 구현해야 할 특별한 이유가 없다면 불변 타입의 장점을 살릴 수 있도록 밸류 타입은 불
변으로 구현한다．

## 2. 아키텍처 개요

응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다

도메인 형역은 도메인 모델을 구현한다

인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다 . 이 영역은 RDBMS 연동을 처리하고，
메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현하고 , 몽고DBB나 레디스의 데이터 연동을 처리한다 .

도메인 영역 , 응용 영역 , 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다 . 대신 인
프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다

### 계층 구조 아키텍처

계층 구조는 그 특정상 상위 계층에서 하위 계충으로의 의존만 존재하고 하위 계층은 상위 계
층에 의존하지 않는다

인프라스트럭처의 기술에 직접적인 의존을하지 않는 것처럼 보이는 경우 어떻게 해야할까?

### DIP

고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈이다. 고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요하다 . 가격 할인 계산 기능을 구현하려면 고객 정보를 구해야 하고 룰을 실행해야 하는데 이 두 기능이 하위 기능이다 . 저수준 모듈은 하위 기능을 실제로 구현한 것이다

고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요하다

DIP를 적용하면 저수준 모듈이 고수준 모듈에 의존하게 된다 . 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데 , 반대로 저수준모듈이 고수준 모듈에 의존한다고 해서 이를 DIP, 즉. 의존 역전 원칙이라고 부른다．

DIP를 적용하면 앞의 다른 영역이 인프라스트럭처 영역에 의존할 때 발생했던 두 가지 문제인구현 교체가 어렵다는 것과 테스트가 어려운 문제를 해소할 수 있다．

구현 기술을 변경하더라도 수정할 필요가 없다 . 사용할 저수준 구현 객쳬를 생성하는 코드만 변경하면 된다．

#### 주의사항

DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 벋하들일 수 있다．
DIP 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데 DIP를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 추출하는 경우가 있다．

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다

### DIP와 아키텍처

인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다 . 인프라스트럭처 계층이 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존（상속）하는 구조가 된다．

DIP를 적용하면 응용 영역과 도메인 영역에 영향을 최소화하면서 구현체를 변경하거나 추가할 수 있다．

DIP를 항상 적용할 필요는 없다 . 사용하는 구현 기술에 따라 완벽한 DIP를 적용하기보다는 구현 기슬게 의존적
인 코드를 도메인에 일부 포함하는 게 효과적일 때도 있다. 또는 추상화 대상이 잘 떠오르지 않을 때도 있다 . 이
럴 때는 무조건 DIP를 시도하지 밀고 DIP의 이점을 얻는 수준에서 적용 범위를 검토해 보자

### 도메인 영역의 주요 구성요소

- 엔티티
  - 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다.  주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다．
- 밸류
  - 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다．배송지 주소를 표현하기 위한 주소나 구매 금액을 위한 금액와 같은 타입이 밸류 타입이다． 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도사용할 수 있다．
- 에그리거트
  - 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 몌를 들어
    주문과 관련된 Order 엔티티 , OrderLine 밸류 , Orderer 밸류 객체를 “주문’ 애그리거트로 묶을 수 있다．
- 리포지터리
  - 도메인 모델의 영속성을 처리한다 . 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하
    거나 저장하는 기능을 제공한다．
- 도메인 서비스
  - 특정 엔티티에 속하지 않은 도메인 로직을 제공한다 . ' 할인 금액 계산'은 상품 , 쿠폰 , 회
    원 등급 . 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데 , 이렇게 도메인 로직이
    여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다

#### 엔티티와 밸류

실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이 아님을 알게 되었다． 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다 . 예를 들어 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다．

도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객쳬이다 . 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다．

또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개넘적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것이다 .

밸류는 불변으로 구현할 것을 권장하며 , 이는 엔티티의 밸류 타입 데이터를 변경할 때는 객체 자쳬를 완전히 교쳬한다는 것을 의미한다. 예를 들어 배송지 정보를 변경하는 코드는 기존 객쳬의 값을 변경하지 않고 다음과 같이 새로운 객쳬를 필드에 할당한다．

#### 애그리거트

애그리거트는콴련 객쳬를하나로 묶은 군집이다 . 애그리거트의 대표적인 예가주문이다. 애그리거트를 사용하면 개별 객제가 아닌 관련 객체를 묶어서 객쳬 군집 단위로 모델을 바라볼수 있게 된다

애그리거트는 군집에 속한 객쳬를 관리하는 루트 엔티티를 갖는다 . 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객쳬를 이용해서 애그리거트가 구현해야 할 기능을 제공한다. 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다．

#### 리포지터리

도메인 객쳬를 지속적으로 사용하려면 RDBMS, NoSQL , 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야 한다 . 이를 위한 도메인 모델이 리포지터리Repository이다. 엔티티나 밸류가 요구사항쩨서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다．리포지터리는 애그리거트 단위로 도메인 객쳬를 저장하고 조회하는 기능을 정의한다 .

### 인프라스트럭처 개요

인프라스트럭처는 표현 영역 , 응용 영역 , 도메인 영역을 지원한다 . 도메인 객쳬의 영속정 처리 , 트랜잭션 , SMTI)클라이언트 , REST 클라이언트 등 다른 영역에서 필요로 하는 프레임워크 , 구현 기술 , 보조 기능을 지원한다. DII）에서 언급한 것처럼 도메인 영역과응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다．
하지만 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다.

구현의 펀리함은 DIP가 주는 다른 장점 （변경의 유연함 , 테스트가 쉬움）만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않다고 생각하다 . 응용 영역과 도메인 영역이 인프라스트럭처에 대한 의존을 완전히 갖지 않도록 시도하는 것은 자칫 구현을 더 복잡하고 어렵게 만들 수 있다．

### 모듈 구성

아키텍처의 각 영역은 별도 패키지에 위치한다 . 패키지 구성 규칙에 정답이 존재하는 것은 아
니지만 영역별로 모듈끼리 위치할 패키지를 구성할 수 있을 것이다

도메인이 크면 위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성한다． 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키 지를 구성한다. 애그리거트 , 모델 , 리포지터리는 같은 패키지에 위치시킨다

도메인이 복잡하면 도메인 모델과 도메인 서비스를 다 별도 패키지에 위치시킬 수도있다．

모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다 . 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다 . 개인적으로는 한 패키지에 가능하면 10-45개 미만으로 타입 개수를 유지하려고 노력한다 . 이 개수가 넘어가면 패키지를 분리하는시도를해본다．
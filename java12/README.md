# Java 12



## 출시일

2019년 3월 19일



## 개선 사항

자바 12의 새로운 개선 사항에 대해 알아봅시다.



### JEP 189: Shenandoah : 저-일시 가비지 수집기(실험)

#### 요약

실행 중인 Java 스레드와 동시에 제거 작업을 수행하여 GC 일시 중지 시간을 줄이는 Senandoah라는 새로운 GC(가비지 수집) 알고리즘을 추가합니다. Senandoah를 사용한 일시 중지 시간은 힙 크기와 무관합니다. 즉, 힙이 200MB인지 200GB인지 여부에 관계없이 일관된 일시 중지 시간을 가질 수 있습니다.

#### 비 목표

이것은 그들을 지배할 유일한 GC가 아닙니다. 응답성보다 처리량이나 메모리 공간을 우선시하는 다른 가비지 수집 알고리즘이 있습니다. Senandoah는 반응성과 예측 가능한 짧은 일시 중지를 중시하는 애플리케이션에 적합한 알고리즘입니다. 목표는 모든 JVM 일시 중지 문제를 해결하는 것은 아닙니다. TTSP(Time To Safe Point) 문제와 같은 GC 이외의 이유로 인해 일시 중지 시간 또는 모니터 인플레이션이 이 JEP의 범위를 벗어납니다.

#### 성공 측정 항목

이 프로젝트는 일관성있는 짧은 gc 일시 중지 시간을 유지할 수 있다면 성공할 것입니다.

#### 기술

최신 기계는 그 어느 때보다도 많은 메모리와 프로세서를 갖추고 있습니다. SLA (Service Level Agreement) 응용 프로그램은 10-500ms의 응답 시간을 보장합니다. 그 목표의 최하위를 맞추기 위해서는 가비지 콜렉션 알고리즘이 필요합니다. 가비지 콜렉션 알고리즘은 프로그램이 가용 메모리에서 실행될 수 있도록 충분히 효율적이지만 실행중인 프로그램을 몇 밀리 초 이상 중단하지 않도록 최적화되어 있습니다. Shenandoah는 우리를 그 목표에보다 가깝게 이동하도록 설계된 OpenJDK의 오픈 소스 저 휴지 시간 수집기입니다.

Shenandoah는 동시 CPU주기와 일시 중지 시간 개선 공간을 교환합니다. 우리는 GC 스레드가 Java 스레드가 실행되는 동안 힙을 압축 할 수있게하는 모든 Java 오브젝트에 대한 간접 포인터를 추가했습니다. 마킹과 압축은 동시에 수행되기 때문에 객체 그래프의 뿌리를 찾아서 업데이트하기 위해 스레드 스택을 스캔 할 수있을만큼 Java 스레드를 잠시 중지하면됩니다.

Shenandoah 알고리즘은이 [PPPJ2016](https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK) 논문에 깊이 설명되어 있습니다.

Shenandoah가 구현되었으며 aarch64 및 amd64 용 Red Hat에서 지원됩니다.

Shenandoah의 개발은 OpenJDK [Shenandoah](http://openjdk.java.net/projects/shenandoah/) 프로젝트에서 수행됩니다. [Shenandoah 위키](https://wiki.openjdk.java.net/display/shenandoah/Main) 페이지 에서 현재 개발 흐름, 구현 세부 사항, 가용성에 대한 자세한 내용을 확인하십시오.

#### 대안

Zing / Azul은 일시 중지 콜렉터를 가지고 있지만 OpenJDK에 대한 작업에 기여하지 않았습니다.

ZGC는 색상 포인터를 기반으로 낮은 일시 중지 수집기가 있습니다. 우리는 두 가지 전략의 성과를 비교하기를 기대합니다.

G1은 병행 및 동시 작업을 수행하지만 동시 대피는 수행하지 않습니다.

CMS는 동시 표시를 수행하지만 일시 중지 시간에 젊은 세대 복사를 수행하며 이전 세대를 압축하지 않습니다. 그 결과 조각화 문제뿐만 아니라 구형 세대의 여유 공간을 관리하는 데 더 많은 시간을 소비하게됩니다.

#### 구성 및 호출 중


시험용 기능으로 Shenandoah는 명령 줄에서 -XX : + UnlockExperimentalVMOptions를 요구합니다. Shenandoah 빌드 시스템은 지원되지 않는 구성에서 빌드를 자동으로 비활성화합니다. 다운 스트림 빌더는 다른 플랫폼에서 --with-jvm-features = -shenandoahgc를 사용하여 Shenandoah 빌드를 비활성화 할 수 있습니다.

Shenandoah GC를 활성화 / 사용하려면 다음 JVM 옵션이 필요합니다. -XX : + UnlockExperimentalVMOptions -XX : + UseShenandoahGC.

Shenandoah GC를 설정하고 조정하는 방법에 대한 자세한 내용은 [Shenandoah wiki](https://wiki.openjdk.java.net/display/shenandoah/Main) 페이지를 참조하십시오.

#### 테스트

Red Hat은 중요한 응용 프로그램에 대한 광범위한 테스트를 수행했습니다. 우리는 많은 Shenandoah 특정 jtreg 테스트를 개발했습니다. Shenandoah는 Fedora 24에서 Fedora로, Rhel 7.4에서 기술 미리보기로 출하됩니다. -XX를 사용하여 표준 OpenJDK 테스트 실행 : + UseShenandoahGC로 충분해야합니다.

#### 위험과 가정

GC 인터페이스 (JEP 304)는 JDK 11에 통합되었으며 이후 많은 확장과 개선이 GC 인터페이스에 이루어졌습니다. 이렇게하면 Shenanodah를 OpenJDK 소스 기반에 추가 할 때의 위험을 최소화 할 수 있습니다. 그 외에도, 합리적으로 처리 할 수없는 모든 Shenandoah 특정 코드 경로는 #ifdef INCLUDE_SHENANDOAHGC 또는 이와 유사한 메커니즘에 의해 보호됩니다. Shenandoah GC는 초기에 실험 기능으로 표시되므로 -XX : + UseShenandoahGC 외에도 -XX : + UnlockExperimentalVMOptions가 필요합니다.



### JEP 230: 마이크로벤치마크 제품군

#### 요약

JDK 소스 코드에 기본 마이크로벤치마크 세트를 추가하고 개발자가 기존 마이크로벤치마크를 실행하고 새 마이크로벤치마크를 쉽게 생성할 수 있습니다.

#### 목표

- [JMH](http://openjdk.java.net/projects/code-tools/jmh)(Java Microbenchmark Harness)을 기준으로 합니다.
- 안정적이고 조정된 벤치마크로서 지속적인 성능 테스트를 목표로 합니다.
  - 기능 릴리즈 및 비기능 릴리즈의 기능 완료 이정표 이후 안정적이고 움직이지 않는 제품군입니다.
  - 적용 가능한 테스트에 대한 이전 JDK 릴리스와의 비교를 지원합니다.
- 간결함
  - 새로운 벤치마크를 쉽게 추가할 수 있습니다.
  - API 및 옵션이 변경되거나, 더 이상 사용되지 않거나, 개발 중에 제거됨에 따라 테스트를 쉽게 업데이트할 수 있습니다.
  - 제작이 용이합니다.
  - 벤치마크를 쉽게 찾고 실행할 수 있습니다.
- JMH 업데이트를 지원합니다.
- 제품군에 약 100개의 벤치마크 집합을 포함합니다.

#### 비 목표 

- 새로운 JDK 기능에 대한 벤치마크를 제공하는 것은 목표가 아닙니다. 이러한 프로젝트의 일환으로 새로운 기능에 대한 벤치마크를 추가할 예정입니다.

- JDK의 모든 것을 포함하는 전체 벤치마크를 만드는 것은 목표가 아닙니다. 이 제품군은 새로 작성된 벤치마크를 사용하거나 적용 범위를 확장하기 위한 노력을 통해 시간이 지남에 따라 계속 확장될 것입니다.

- 마이크로벤치마크에서 이진 의존성을 처리하기 위한 솔루션을 제공하는 것은 목표가 아닙니다. 이에 대한 지원은 나중에 추가될 수 있습니다.

#### 기술

마이크로벤치마크 제품군은 단일 디렉토리에 JDK 소스 코드와 함께 배치되며, 구축되면 단일 JAR 파일을 생성합니다. 코로케이션은 개발 중에 벤치마크 추가 및 위치를 단순화합니다. JMH는 벤치마크를 실행할 때 사용자가 현재 관심 있는 벤치마크만 실행할 수 있는 강력한 필터링 기능을 제공합니다. 정확한 위치는 아직 정해지지 않았습니다.

벤치마킹은 일반적으로 이전 빌드 또는 심지어 릴리즈와 비교해야 하므로 마이크로벤치마크는 새로운 JDK의 기능을 타깃팅하는 벤치마크의 경우 JDK(N)를 지원해야 하며 이전 릴리스의 기능을 타깃팅하는 벤치마크의 경우 JDK(N-1)를 지원해야 합니다. 즉, JDK 12의 경우 구조 및 빌드 스크립트가 JDK 12와 JDK 11에 대한 벤치마크 컴파일 기능을 지원해야 합니다. 또한 테스트 중인 JDK 영역을 설명하는 Java 패키지 이름을 사용하여 벤치마크를 세분화할 예정입니다.

다음 디렉토리 구조가 제안됩니다.

```powershell
jdk/jdk
   .../make/test (Shared folder for Makefiles)
   .../test (Shared folder for functional tests)
      .../micro/org/openjdk/bench
         .../java (subdirectories similar to JDK packages and modules)
         .../vm (subdirectories similar to HotSpot components)
```

마이크로벤치마크 제품군의 건물은 일반 JDK 빌드 시스템과 통합됩니다. 개발자 및 마이크로벤치마크 제품군 구축에 관심이 없는 다른 사용자들을 위해 일반 JDK 빌드 중에는 실행되지 않는 별도의 대상이 될 것입니다. 마이크로벤치마크 제품군을 구축하려면 사용자가 특별히 make-microbenchmark 등을 실행해야 합니다. 또한 make test="micro:regexp"을 사용하여 실행 중인 벤치마크가 지원됩니다. 로컬 환경을 설정하는 방법에 대한 지침은 문서/테스트.md|html에 기록됩니다.

벤치마크는 모두 일부 장치 테스트가 테스트NG 또는 jtreg에 의존하는 것과 동일한 방식으로 JMH에 의존합니다. 따라서 JMH에 대한 의존도가 새로운 반면, 유사한 종속성을 가진 다른 부품도 있습니다. jtreg와 비교한 한 가지 차이점은 JMH가 모두 빌드 중에 사용되며 결과 JAR 파일의 일부로 패키징된다는 점입니다.

마이크로벤치마크 제품군의 벤치마크 세트는 [JMH JDK 마이크로벤치마크 프로젝트](http://openjdk.java.net/projects/code-tools/jmh-jdk-microbenchmarks/)에서 가져올 예정입니다. 이미 내부적으로 사용되고 있는 튜닝되고 테스트된 마이크로벤치 마크의 집합을 구성합니다. 개방형 질문은 이 독립 실행형 프로젝트를 전체적으로 배치된 제품군으로 마이그레이션할지, 아니면 보다 오래 지속되는 회귀 테스트를 위한 안정화 포리스트로 유지할지 여부입니다.

그러나 모든 사용자는 분석을 수행할 때 실행 기계 및 JDK와 같은 다른 파라미터가 안정적이고 비교 가능한지 확인해야 합니다. 일반적인 경우 벤치마크는 1분 이내에 전체 실행을 완료할 수 있어야 합니다. 이는 대규모 또는 장기 실행 벤치마크의 래퍼 프레임워크가 아닙니다. 목표는 빠르고 타겟화된 벤치마크 제품군을 제공하는 것입니다. 일부 예외적인 경우 벤치마크는 안정적인 결과를 얻기 위해 워밍업 또는 런타임이 더 길어질 수 있지만, 최대한 피해야 합니다. 대규모 워크로드에 대한 일반적인 래퍼 역할을 하는 것은 이 제품군의 목표가 아닙니다. 그보다는 더 큰 벤치마크에서 중요한 구성 요소나 방법을 추출하여 이 부분만 마이크로벤치 마크로 강조합니다.

이 프로젝트의 일환으로 [wiki.openjdk.java.net](https://wiki.openjdk.java.net/)에 새로운 페이지가 생성되어 새로운 벤치마크를 개발하는 방법을 설명하고 벤치마크를 추가하는 데 필요한 요구 사항을 설명할 수 있습니다. 이 요구 사항은 코딩 표준 준수, 재현 가능한 성능, 벤치마크 및 측정 대상의 명확한 문서화를 의무화합니다.

#### 대안

마이크로벤치마크 제품군을 [별도의 프로젝트](http://openjdk.java.net/projects/code-tools/jmh-jdk-microbenchmarks/)로 유지 관리하세요.

코로케이션은 특히 프로젝트 저장소(Valhalla, Amber 등)에서 모든 새로운 기능 개발의 많은 부분을 수행하는 환경에서 새로운 기능에 대한 벤치마크 추가를 간소화합니다. 개별 프로젝트 모델에서 특히 복잡한 것으로 입증된 사례는 Javac 자체에 대한 변경 사항을 테스트하는 것입니다. 따라서 각 JDK를 사용하여 벤치마크 제품군을 명시적으로 재구성해야 합니다. Co-locing을 수행하면 성능 추적을 위해 사전 구축된 벤치마크 번들을 사용하는 것을 금지하지 않으면서 이러한 특정 사용 사례를 더욱 우아하게 해결할 수 있습니다. 안정감 있는 검사를 할 수 있습니다.

#### 테스트

이 마이크로벤치 마크는 성능 팀이 정기적인 성능 테스트의 일환으로 검증하여 안정적이고 조정된 정확한 마이크로벤치 마크만 추가되도록 합니다. 또한 벤치마크가 의도한 기능을 테스트할 수 있도록 사례별로 평가 및 프로파일링을 수행합니다. 모든 테스트는 모든 해당 플랫폼에서 여러 번 실행해야 안정성이 보장됩니다.

#### 위험

- JDK 빌드는 JMH 버전에 따라 다릅니다. JDK 빌드 시스템은 JMH의 바이너리 버전에 다운로드하거나 다른 방식으로 액세스할 수 있어야 하며, 필요한 경우 JMH의 최신 버전으로 업데이트할 수 있어야 합니다. TestNG 및 기타 라이브러리에 대한 종속성이 유사하기 때문에 이 문제는 해결하기가 쉬운 문제가 될 수 있습니다. JMH 종속성은 마이크로벤치마크 제품군을 구축하려는 사용자에게만 표시되며 다른 빌드 대상은 JMH에 종속되지 않습니다.
- 빌드 시간이 크게 늘어납니다. 일반 개발자 JDK 빌드에는 벤치마크 제품군이 필요하지 않으므로 별도의 빌드 대상이 됩니다.
- 새로운 벤치마크에서 테스트 불안정성이 발생할 수 있습니다. 추가된 각 벤치마크에 대한 철저한 검토와 테스트가 필요합니다.
- 소스 코드 저장소 크기가 증가합니다. 이름에서 알 수 있듯이 마이크로벤치마크는 작지만, 시간이 지남에 따라 큰 집합이 있기를 바랍니다. 기본 크기는 저장소 외부에서 처리해야 하는 리소스 때문입니다.
- 특정 유형의 벤치마크를 생성하려면 2진수 스토리지를 사용할 수 있어야 합니다. 일부 벤치마크는 외부 라이브러리 또는 벤치마크의 일부로 사용되는 XML 문서 및 소스 코드 파일과 같은 대규모 정적 리소스를 사용합니다. 현재 이에 대한 해결책은 없지만, 이는 이러한 유형의 의존성을 가진 벤치마크만 제한할 것입니다. 마이크로벤치마크 소스 코드의 일부로 2진수가 아닌 소규모 리소스가 허용될 수 있습니다.



### JEP 334 : JVM 상수 API

#### 동기

모든 Java 클래스 파일에는 클래스의 바이트 코드 명령어 피연산자를 저장하는 상수 풀이 있습니다. 대체로 말하자면, 상수 풀의 항목은 클래스 및 메소드와 같은 런타임 아티팩트 또는 문자열 및 정수와 같은 간단한 값을 설명합니다. 이러한 항목은 모두 ldc 명령어 ( "로드 상수")에 대한 피연산자로 사용될 수 있기 때문에 로드 가능한 상수로 알려져 있습니다. invokedynamic 명령의 부트 스트랩 메소드의 정적 인수 목록에도 나타날 수 있습니다. ldc 또는 invokedynamic 명령을 실행하면로드 가능한 상수가 Class, String 또는 int와 같은 표준 Java 유형의 "실제"값으로 해석됩니다.

클래스 파일을 조작하는 프로그램은 바이트 코드 명령어와 로드 가능한 상수를 모델링 해야합니다. 그러나 표준 Java 유형을 사용하여 로드 가능한 상수를 모델링하는 것은 부적절합니다. 스트링을 기술하는로드 가능한 상수 (CONSTANT_String_info 엔트리)는 "라이브" String 객체를 생성하는 것이 간단하지만 클래스를 설명하는로드 가능한 상수 (CONSTANT_Class_info 엔트리)에서 문제가되기 때문에 허용 될 수 있습니다. "live"Class 객체는 클래스 로딩의 정확성과 일관성에 의존합니다. 불행하게도, 클래스 로딩은 많은 환경 의존성과 실패 모드를 가지고있다 : 원하는 클래스가 존재하지 않거나 요청자가 접근 할 수 없다; 클래스 로딩의 결과는 컨텍스트에 따라 다릅니다. 로딩 클래스에는 부작용이 있습니다. 때로는 클래스 로딩이 전혀 불가능할 수도 있습니다 (예 : 설명되는 클래스가 아직 존재하지 않거나로드 할 수없는 경우, 같은 클래스를 컴파일하는 동안 또는 jlink-time 변환 중에).

결과적으로로드 가능한 상수를 처리하는 프로그램은 클래스와 메소드를 조작 할 수 있다면 더 간단해질 것이고 메소드 핸들과 동적으로 계산 된 상수와 같은 잘 알려지지 않은 공적은 순수하게 명목상의 상징적 인 형태로 나타납니다.

- 바이트 코드 파싱 및 생성 라이브러리는 클래스 및 메서드 핸들을 기호 형식으로 설명해야합니다. 표준 메커니즘이 없으면 ASM 핸들과 같은 디스크립터 유형 또는 문자열의 튜플 (메소드 소유자, 메소드 이름, 메소드 설명자) 또는 이들의 임시 (및 오류가 발생하기 쉬운) 인코딩과 같은 임시 메커니즘에 의존해야합니다. 단일 문자열로.

- 바이트 코드 (예 : LambdaMetafactory)를 회전하여 작동하는 invokedynamic의 부트 스트랩은 "라이브"클래스 및 메소드 핸들이 아닌 기호 도메인에서 작동 할 수 있으면 더 간단합니다.

- 컴파일러 및 오프라인 변환기 (예 : jlink 플러그인)는 실행중인 VM에로드 할 수없는 클래스의 클래스 및 멤버를 설명해야합니다. 컴파일러 플러그인 (예 : 주석 프로세서)은 기호 요소로 프로그램 요소를 비슷하게 설명해야합니다.

이러한 종류의 라이브러리와 도구는 모두로드 가능한 상수를 설명하는 단일 표준 방법을 사용하면 도움이됩니다.

#### 기술

새로운 패키지 java.lang.invoke.constant에로드 가능한 상수의 각 종류를 설명 할 수있는 값 기반 심볼 참조 (JVMS 5.1) 유형의 패밀리를 정의합니다. 기호식 참조는 클래스 로딩 또는 액세스 가능성 컨텍스트와 별도로 순전히 공칭 형식의로드 가능한 상수를 설명합니다. 일부 클래스는 자체적 인 기호 참조 (예 : String)로 작동 할 수 있습니다. linkable 상수를 위해 우리는이 상수들을 설명하기위한 명목상의 정보를 담고있는 상징적 인 참조 형들의 집합 (ClassDesc, MethodTypeDesc, MethodHandleDesc, 그리고 DynamicConstantDesc)을 정의한다.

API 사양의 초안 스냅 샷은 [여기](http://cr.openjdk.java.net/~vromero/8210031/javadoc.21/overview-summary.html)에서 찾을 수 있으며 [JEP 303](http://openjdk.java.net/jeps/303)의 기능과의 관계에 대한 자세한 내용은이 동반자 문서에서 확인할 수 있습니다.

#### 종속성

이 JEP는 원래 [JEP 303 (LDC 및 INVOKEDYNAMIC 지침의 내장 함수)](http://openjdk.java.net/jeps/303)의 하위 기능이었습니다. JEP 303은 이제이 JEP에 의존합니다.



예제에 대해 알아봅니다.

#### String # indent (int)

간단하게 들릴 수 있듯이이 메서드를 사용하면 String 인스턴스의 들여 쓰기를 조정할 수 있습니다.

격차를 염두에 둔다.

```java
String result = "foo\nbar\nbar2".indent(4);
System.out.println(result);
//    foo
//    bar
//    bar2

System.out.println(result.length()); // 25
```

이것은 [JEP-326 - 구현 세부 사항](https://openjdk.java.net/jeps/326)을 둘러싼 논쟁으로 JDK 12에서 철회 된 [원시 문자열 리터럴](https://mail.openjdk.java.net/pipermail/jdk-dev/2018-December/002402.html)을 보완하기로되어 있습니다.



#### String # transform (function)

[JDK-8203442](https://bugs.openjdk.java.net/browse/JDK-8203442)에서 소개 된 약간의 메소드로, 제공된 String 인스턴스를 입력으로 제공하고 해당 함수가 반환하는 출력을 반환합니다.

이제 예제를 살펴 보겠습니다.

```java
var result = "foo".transform(input -> input + " bar");
System.out.println(result); // foo bar
```

다음과 같이 연결할 수도 있습니다.

```java
var result = "foo"
  .transform(input -> input + " bar")
  .transform(String::toUpperCase)
System.out.println(result); // FOO BAR
```





#### JEP 340: 2개가 아닌 1개의 AArch64 포트

#### 요약

32비트 ARM 포트와 64비트 aarch64 포트를 유지하면서 arm64 포트와 관련된 모든 소스를 제거합니다.

#### 동기

이 포트를 제거하면 모든 기여자가 단일 64비트 ARM 구현에 총력을 기울이고 두 포트를 유지하는 데 필요한 중복 작업을 제거할 수 있습니다.

#### 묘사

JDK에는 두 개의 64비트 ARM 포트가 있습니다. 이러한 주 소스는 src/hotspot/cpu/arm 및 open/src/hotspot/cpu/aarch64 디렉토리에 있습니다. 두 포트 모두 aarch64 구현을 생성하지만, 이 JEP를 위해 Oracle이 기여한 전자를 arm64로, 후자를 arch64로 지칭합니다.

다음은 이 JEP의 일부로 완료될 작업입니다.

- open/src/hotspot/cpu/arm의 32비트 빌드 대 64비트 관련 모든 암64 관련 소스 및 #ifdefs를 제거합니다.
- 이 포트와 관련된 #ifdefs에 대해 나머지 JDK 소스를 검색합니다.
- 이 포트를 빌드하기 위한 빌드 옵션을 제거합니다. aarch64 포트를 64비트 ARM 아키텍처의 기본 빌드로 설정합니다.
- 나머지 32비트 ARM 포트가 이 JEP와 관련된 변경 전에는 존재하지 않았던 퇴행 없이 적합성 테스트를 계속 작성하고 실행하는지 확인합니다.





### JEP 341 : 기본 CDS 아카이브

#### 요약

64 비트 플랫폼에서 기본 클래스 목록을 사용하여 클래스 데이터 공유 (CDS) 아카이브를 생성하도록 JDK 빌드 프로세스를 향상 시키십시오.

#### 목표

- 즉시 사용 가능한 시작 시간 향상
- 사용자가 실행할 필요가 없음 -Xshare : CDS 혜택을 누리십시오

#### 비 목표

- 크로스 컴파일 된 빌드가 아닌 기본 빌드에 대해서만 기본 아카이브를 생성합니다.
- 64 비트 빌드에 대해서만 기본 아카이브를 생성합니다. 나중에 32 비트 빌드에 대한 지원이 추가 될 수 있습니다.

#### 자극

JDK 8u40 이후로 기본 CDS 기능에 많은 개선 사항이 추가되었습니다. CDS를 활성화함으로써 제공되는 시작 시간 및 메모리 공유 이점이 크게 증가했습니다. JDK 11 조기 액세스 빌드 14를 사용하여 Linux / x64에서 측정 한 결과는 HelloWorld를 실행하는 시작 시간이 32 % 단축되었음을 보여줍니다. 다른 64 비트 플랫폼에서 비슷하거나 더 높은 시작 성능이 향상되었습니다.

현재, JDK 이미지는 빌드시 생성 된 기본 클래스 목록을 lib 디렉토리에 포함합니다. JDK에서 제공되는 기본 클래스 목록을 사용하는 경우에도 CDS를 활용하려는 사용자는 java -Xshare : dump를 추가 단계로 실행해야합니다. 이 옵션은 문서화되어 있지만 많은 사용자는이를 인식하지 못합니다.

#### 기술

이미지를 링크 한 후 java -Xshare : dump를 실행하도록 JDK 빌드를 수정하십시오. (일반적인 경우보다 나은 메모리 레이아웃을 얻으려면 GC 힙 크기를 미세 조정하는 등의 추가 명령 행 옵션이 포함될 수 있습니다.) 결과로 나오는 CDS 아카이브를 lib / server 디렉토리에 그대로 둡니다.

JDK 11 (JDK-8197967)의 서버 VM에서는 기본적으로 -Xshare : auto가 활성화되었으므로 사용자는 CDS 기능을 자동으로 사용합니다. CDS를 사용하지 않으려면 -Xshare : off를 사용하십시오.

고급 요구 사항 (예 : 애플리케이션 클래스, 다양한 GC 구성 등을 포함하는 맞춤 클래스 목록 사용)을 사용하는 사용자는 이전과 마찬가지로 맞춤 CDS 보관 파일을 만들 수 있습니다.

#### 대안

기본 CDS 아카이브를 빌드하되 -Xshare : auto는 사용 불가능하게하십시오.

이 접근법은 더 안전합니다. 기본 CDS 아카이브는 JDK Windows 설치 프로그램에서 생성 되었기 때문에 CDS는 Windows에서 기본적으로 활성화되어 있지만 다른 플랫폼에서는 그렇지 않습니다. 사용자가 의식적으로 선택하지 않고 갑자기 CDS를 활성화하면 예를 들어 문서화되지 않은 JVM의 시작 순서에 의존하는 경우 기존 응용 프로그램에 영향을 줄 수 있습니다.

-Xshare : auto가 비활성화 된 경우 (즉, JDK-8197967을 되돌릴 경우) 기본 CDS 아카이브가 JDK에 포함되어있는 경우에도 CDS를 사용하려면 명령 줄에 명시 적으로 -Xshare : auto를 지정해야합니다. 이렇게하면 사용자는 기본 CDS 아카이브를 사용하여 동화 기간을 갖게되며 이후에 JDK-8197967을 복원 할 수있게됩니다.

이 방법의 장점은 다음과 같습니다.

- 즉, 기본 동작은 즉시 변경되지 않습니다.
- 일반적인 경우에 대한 java -Xshare : 덤프 단계를 제거하여 기본 아카이브로 CDS 사용 가능성을 향상시킵니다.
- 즉시 기본 동작을 변경할 위험없이 사용자에게 기본 아카이브를 제공하여 테스트 노출을 향상시킵니다.

이 접근 방식의 문제점은 다음과 같습니다.

- -Xshare:auto를 왔다갔다 하면서 혼동을 일으킵니다.
- 이는 CDS 아카이브를 포함하는 것이 위험이 크다는 잘못된 가정에 근거합니다. CDS 기본 아카이브는 Windows (클라이언트)에서 10 년 이상 사용 가능하며 거의 문제가 없습니다.
- 사용자는 명시 적으로 -Xshare : auto 옵션을 설정 한 경우에만이 기능을 테스트 할 수 있습니다. 그러나 CDS에 관심이있는 (또는 알고있는) 사용자는 이미 CDS 아카이브를 작성하고 이전 릴리스에 대한 명령 줄을 수정하게됩니다. 즉, 기본 아카이브를 출하하지 않고 CDS를 이미 테스트했습니다. 이 접근법이 실제로 더 많은 테스트를 초래할 것이라는 점은 의심 스럽습니다.

이와는 대조적으로,이 JEP에서 제안 된 접근법을 사용하면 많은 개발자가 JDK를 빌드하거나 조기 액세스 릴리스를 사용할 때 암시 적으로 CDS를 테스트하여보다 많은 테스트를 수행하게됩니다.



### JEP 325 : Switch 표현식

베타 스위치 익스프레션 기능은 switch 구문을 확장해 구문 또는 식으로 사용할 수 있도록 한다. 이를 통해 코딩을 간소화할 수 있다. 두 형식 모두 "전통적인" 또는 "간소화된" 범위 및 흐름 제어 동작을 사용할 수 있게 된다. 이런 변화를 통해 "일상적인" 코딩이 더 간소화되고 switch에서 패턴 매칭(pattern matching)을 사용하기 위한 기반을 마련했다.

자바 제작자들이 패턴 매칭을 지원하도록 전환함에 따라 기존 switch 문의 불일치가 장애물이 된다. 여기에는 switch 블록의 기본 흐름 제어 동작, 블록이 단일 범위로 취급되는 switch 블록의 기본 범위 지정, 문으로만 작동하는 switch 등이 포함된다.

현재 자바의 switch 문 동작은 기본적으로 C++와 같은 언어와 거의 비슷하고 fallthrough 의미 체계를 지원한다. 이 흐름 제어는 저수준 코드를 작성하는 데 유용하다. 그러나 switch가 더 높은 수준의 컨텍스트에서 사용되면 특유의 잦은 오류로 인해 유연함으로 얻는 이점이 무의미해진다.

예를 들어, 다음 코드에서 많은 `break`문이 불필요하게 장황하게 만들고, 시각적 인 노이즈로 인해 오류를 디버그하기가 어려울 수 있습니다. 누락 된 `break`문으로 우발적 인 오류 가 발생한다는 의미입니다.

```java
switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}
```

레이블의 일치하는 경우 레이블 오른쪽의 코드 만 실행된다는 것을 나타내는 "case L ->"형식의 새 스위치 레이블을 소개합니다. 예를 들어 이전 코드를 다음과 같이 작성할 수 있습니다.

```java
switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);
    case TUESDAY                -> System.out.println(7);
    case THURSDAY, SATURDAY     -> System.out.println(8);
    case WEDNESDAY              -> System.out.println(9);
}
```

이 예제는 또한 여러 사례 레이블을 사용합니다. 단일 스위치 레이블에 쉼표로 구분 된 여러 레이블을 지원하는 것이 좋습니다.

"case L ->"스위치 레이블의 오른쪽에있는 코드는 표현식, 블록 또는 (편의상) throw 문으로 제한됩니다. 이것은 구문이 지역 변수를 도입 할 때 블럭에 포함되어야하고 따라서 스위치 블럭의 다른 구문의 범위에 포함되어서는 안되는 결과를 낳습니다. 이렇게하면 로컬 변수의 범위가 전체 스위치 블록 인 "전통적인"스위치 블록의 또 다른 성가심을 제거 할 수 있습니다.

```java
switch (day) {
    case MONDAY:
    case TUESDAY:
        int temp = ...
        break;
    case WEDNESDAY:
    case THURSDAY:
        int temp2 = ...     // Why can't I call this temp?
        break;
    default:
        int temp3 = ...     // Why can't I call this temp?

```

많은 기존 switch 문은 본질적으로 스위치 식을 시뮬레이션합니다. 각 구문은 공통 대상 변수에 할당하거나 값을 반환합니다.

```java
int numLetters;
switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        numLetters = 6;
        break;
    case TUESDAY:
        numLetters = 7;
        break;
    case THURSDAY:
    case SATURDAY:
        numLetters = 8;
        break;
    case WEDNESDAY:
        numLetters = 9;
        break;
    default:
        throw new IllegalStateException("Wat: " + day);
}
```

이를 문장으로 표현하는 것은 우회적이고 반복적이며 오류가 발생하기 쉽습니다. 저자는 우리가 매일 numletters의 값을 계산해야 한다는 것을 표현하고자 했습니다. 스위치 식을 사용하여 보다 명확하고 안전하게 다음과 같이 직접 말할 수 있어야 합니다.

```java
int numLetters = switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> 6;
    case TUESDAY                -> 7;
    case THURSDAY, SATURDAY     -> 8;
    case WEDNESDAY              -> 9;
};
```

차례대로 스위치를 확장하여 표현식을 확장하면 흐름 분석 확장 (표현식은 항상 값을 계산하거나 갑작스럽게 완료해야 함)과 같은 일부 추가 요구 사항이 발생하고 스위치 표현식의 일부 경우에는 값을 산출하는 대신 예외가 발생합니다.

#### 기술

"전통적인"스위치 블록에 추가하여 새로운 "단순화 된"양식과 새로운 "case L ->"스위치 레이블을 추가 할 것을 제안합니다. 레이블이 일치하면 화살표 레이블의 오른쪽에있는 있는 표현식 또는 문만 실행되며, 통과하지 않습니다. 예를 들어 다음과 같은 방법을 사용할 수 있습니다.

```java
static void howMany(int k) {
    switch (k) {
        case 1 -> System.out.println("one");
        case 2 -> System.out.println("two");
        case 3 -> System.out.println("many");
    }
}

howMany(1); //one
howMany(2); //tow
howMany(3); //many
```

switch 문을 확장하여 표현식으로 추가로 사용할 수 있습니다. 일반적인 경우 스위치 식은 다음과 같습니다.

```java
T result = switch (arg) {
    case L1 -> e1;
    case L2 -> e2;
    default -> e3;
};
```

스위치 식은 폴리 표현식입니다. 대상 유형을 알 경우 이 유형은 각 구문으로 푸시됩니다. 스위치 표현식 유형은 알려진 경우 대상 유형이며, 그렇지 않은 경우 각 케이스 구문의 유형을 결합하여 독립형 유형을 계산합니다.

대부분의 스위치 표현식은 "case L ->" 스위치 라벨의 오른쪽에 하나의 표현식을 가집니다. 전체 블록이 필요한 경우 인수를 수행하기 위해 중단 문을 확장했으며, 이는 동봉 스위치 식 값이 됩니다.

스위치 표현식은 폴리 표현식입니다. 목표 유형이 알려지면이 유형이 각 팔로 밀어 넣어집니다. 스위치 표현식의 유형은 알 수있는 경우 목표 유형입니다. 그렇지 않은 경우 독립 실행 형은 각 사례 암의 유형을 결합하여 계산됩니다.

대부분의 스위치 표현식은 "case L ->"스위치 레이블의 오른쪽에 단일 표현식을 갖습니다. 전체 블록이 필요할 경우 break 문을 확장하여 인수를 취합니다.이 인수는 둘러싸는 스위치 식의 값이됩니다.

```java
int j = switch (day) {
    case MONDAY  -> 0;
    case TUESDAY -> 1;
    default      -> {
        int k = day.toString().length();
        int result = f(k);
        break result;
    }
};
```

switch 표현식은 switch 문과 마찬가지로 "case L :"스위치 레이블 (fall-through 의미 체계를 의미 함)이있는 "전통적인"스위치 블록을 사용할 수도 있습니다. 이 경우 value with break 문을 사용하여 값이 산출됩니다.

```java
int result = switch (s) {
    case "Foo": 
        break 1;
    case "Bar":
        break 2;
    default:
        System.out.println("Neither Foo nor Bar, hmmm...");
        break 0;
};
```

두 가지 형태의 중단 (값이 있거나 없음)은 메소드에서 리턴의 두 가지 형태와 유사합니다. 두 가지 형태의 리턴은 즉시 메소드의 실행을 종료합니다. 비 - 공법 (non-void method)에서, 메소드의 호출자에게 주어진 값이 추가로 제공되어야한다. (구분 표현식 값과 구분 레이블 양식 간의 모호성은 비교적 쉽게 처리 할 수 있습니다.)

스위치 식의 경우는 철저해야합니다. 가능한 모든 값에 대해 일치하는 스위치 레이블이 있어야합니다. 실제로 이는 일반적으로 기본 절이 필요하다는 것을 의미합니다. 그러나 모든 알려진 경우를 다루는 enum 스위치 식 (결국 봉인 된 형식의 식을 전환 함)의 경우 컴파일러에서 열거 형 정의가 컴파일 시간과 런타임 사이에 변경되었음을 나타내는 기본 절을 삽입 할 수 있습니다. (이것은 개발자가 오늘날 손으로하는 일이지만, 컴파일러가 삽입하는 것은 방해가 적어 손으로 작성된 것보다 더 자세한 설명적인 오류 메시지를 가질 가능성이 높습니다.)

또한 스위치 식은 값으로 정상적으로 완료되거나 예외를 throw해야합니다. 이것은 여러 가지 결과를 낳습니다. 첫째, 컴파일러는 모든 스위치 레이블에 대해 일치하는 경우 값을 산출 할 수 있는지 확인합니다.

```java
int i = switch (day) {
    case MONDAY -> {
        System.out.println("Monday"); 
        // ERROR! Block doesn't contain a break with value
    }
    default -> 1;
};
i = switch (day) {
    case MONDAY, TUESDAY, WEDNESDAY: 
        break 0;
    default: 
        System.out.println("Second half of the week");
        // ERROR! Group doesn't contain a break with value
};
```

또 다른 결과는 제어 명령문 인 break, return 및 continue가 다음과 같은 switch 표현식을 뛰어 넘을 수 없다는 것입니다.

```java
for (int i = 0; i < MAX_VALUE; ++i) {
  int k = switch (e) { 
    case 0:  
      break 1;
    case 1:
      break 2;
    default: 
      continue z; 
      // ERROR! Illegal jump through a switch expression 
  };
  ...
}
```

기회의 대상으로 float, double 및 long과 같이 이전에 허용되지 않은 기본 유형 (및 상자 유형)에 대한 전환을 지원하도록 스위치를 확장 할 수 있습니다.



### JEP 344: G1에 대해 중단 가능한 혼합 컬렉션

#### 요약

일시 중지 대상을 초과할 수 있는 경우 G1 혼합 컬렉션을 중단합니다.

#### 비 목표

G1의 모든 일시 중지를 중단합니다.

#### 동기

G1의 목표 중 하나는 수집 일시 중지에 대해 사용자가 제공한 일시 중지 시간 목표를 충족시키는 것입니다. G1은 고급 분석 엔진을 사용하여 수집 중에 수행할 작업량을 선택합니다(일부 애플리케이션 동작에 기반함). 이 선택 결과 집합이라고 하는 영역 집합이 생성됩니다. 수집 세트가 결정되고 수집이 시작되면 G1은 수집 세트의 모든 영역에 있는 모든 실시간 개체를 중지하지 않고 수집해야 합니다. 이 동작은 휴리스틱스가 너무 큰 컬렉션 세트를 선택하는 경우 G1이 일시 중지 시간 목표를 초과하게 할 수 있습니다. 예를 들어, 휴리스틱스가 "정기" 데이터에 대해 작동하도록 응용 프로그램의 동작이 변경될 경우 발생할 수 있습니다. 특히 수집 세트에 오래된 영역이 너무 많이 포함될 수 있는 혼합 컬렉션 중에 이러한 현상이 관찰될 수 있습니다. 휴리스틱스가 컬렉션에 대해 잘못된 작업량을 반복적으로 선택하는 경우 탐지하는 메커니즘이 필요하며, 그렇다면 G1이 단계별로 수집 작업을 점진적으로 수행하도록 하여 각 단계 후 컬렉션이 중단될 수 있습니다. 이러한 메커니즘을 통해 G1은 일시 중지 시간 목표를 더 자주 충족할 수 있습니다.

#### 기술

G1이 컬렉션 세트 선택 휴리스틱스가 잘못된 수의 영역을 반복적으로 선택한다는 것을 발견하면 컬렉션 세트를 필수 부품과 선택적 부품으로 두 부분으로 분할하는 혼합 컬렉션을 수행하는 보다 점진적인 방법으로 전환합니다. 필수 부품은 G1이 점진적으로 처리할 수 없지만(예: 젊은 영역) 효율성 향상을 위해 이전 영역을 포함할 수도 있는 컬렉션 세트의 부분으로 구성됩니다. 예를 들어, 이는 예측 컬렉션 세트의 80%가 될 수 있습니다. 이전 영역으로만 구성된 예측 컬렉션 세트의 나머지 20%가 선택적 부품을 형성합니다.

G1이 필수 부품 수집을 마치면 시간이 남으면 G1은 훨씬 세분화된 수준에서 선택 부품을 수집하기 시작합니다. 이 옵션 부품의 세부적인 컬렉션은 한 번에 한 영역까지 남은 시간에 따라 달라집니다. 선택적 컬렉션 세트의 일부에 대한 컬렉션을 완료한 후 G1은 남은 시간에 따라 컬렉션을 중지하기로 결정할 수 있습니다.

예측이 다시 정확해짐에 따라 필수 부품이 다시 모든 컬렉션 세트로 구성될 때까지 컬렉션의 선택적 부분은 점점 더 작아집니다(즉, G1은 완전히 휴리스틱에 의존). 예측이 다시 부정확해지면 다음 컬렉션은 필수 부품과 선택 부품으로 다시 구성됩니다.

#### 대안

- 분석 엔진과 휴리스틱스를 개선하여 잘못된 예측을 하지 않도록 합니다. 휴리스틱스 자체가 흥미로운 목표이긴 하지만, 휴리스틱스가 이전 애플리케이션 동작에 따라 다르다는 점을 고려하면 100% 정확한 휴리스틱스를 얻는 것은 불가능하다. 그러나, 향상된 휴리스틱스는 자동으로 이러한 메커니즘의 필요성을 줄여줍니다.

- 예측과 관련하여 항상 "안전 여유"를 사용합니다. 예를 들어 예측이 x를 반환하는 경우 항상 0.8 * x(안전 여유도 20%)를 사용합니다. 대부분의 경우 이 기능은 작동하지만 예측이 작동하면 최적의 성능을 발휘하지 못할 수 있습니다. 이는 G1이 일시 중지 대상의 80%만 사용한다는 것을 의미합니다.

- 기존 제거 실패 메커니즘을 재사용하여 혼합 컬렉션을 중단합니다. 이러한 중단 시 컬렉션에서 해당 영역을 해제할 수 있다는 보장은 없기 때문에 이 방법이 대안으로 거부되었습니다. 제안하는 메커니즘은 지역 단위로 설정된 수집 공간을 회수하여 공간 회수 진행률을 보장합니다. 이는 G1의 세분화된 공간 회수입니다.

#### 테스트

구현을 구성하는 개별 C++ 부품은 C++ 유닛 테스트를 사용하여 테스트해야 합니다. 중단 가능한 혼합 컬렉션 코드는 G1 GC의 필수 부분이므로 기존 테스트를 실행하는 것만으로도 코드가 실행됩니다.

#### 위험 및 가정

- 컬렉션 세트를 필수 및 선택적 부품으로 분할할 때 선택적 컬렉션 세트 부품에 대해 일부 추가 데이터를 유지해야 합니다. 따라서 수집 세트 부분(옵션)을 사용하는 혼합 컬렉션에만 1%보다 작은 약간의 CPU 오버헤드가 부과됩니다.
- 선택적 컬렉션 세트 부품을 사용하는 혼합 컬렉션 동안 기본 메모리 사용량도 증가할 수 있습니다. 선택적 부분의 영역에 대한 일부 추가 들어오는 포인터는 해당 혼합 수집 중에 추적해야 하기 때문입니다.



### JEP 346: 사용되지 않은 커밋된 메모리를 G1에서 즉시 반환

#### 요약

G1 가비지 수집기를 개선하여 유휴 상태일 때 Java 힙 메모리를 운영 체제에 자동으로 반환합니다.

#### 비 목표

- Java 프로세스 간에 커밋되지만 비어 있는 페이지를 공유합니다. 메모리는 운영 체제에 반환(커밋되지 않음)되어야 합니다.
- 메모리를 제공하는 프로세스는 CPU 리소스를 절약할 필요도 없고 즉각적으로 사용할 필요도 없습니다.
- 사용 가능한 메모리가 아닌 다른 방법을 사용하여 메모리를 반환합니다.
- G1이 아닌 다른 수집기를 지원합니다.

#### 성공 측정 항목

G1은 애플리케이션 작업이 매우 낮은 경우 적절한 기간 내에 사용되지 않는 Java 힙 메모리를 해제해야 합니다.

#### 동기

현재 G1 가비지 수집기는 커밋된 Java 힙 메모리를 적시에 운영 체제에 반환할 수 없습니다. G1은 전체 GC 또는 동시 주기 동안 Java 힙의 메모리만 반환합니다. G1은 전체 GC를 완전히 방지하려고 노력하고 Java 힙 점유 및 할당 활동에 기반한 동시 사이클만 트리거하므로 외부적으로 강제로 실행하지 않으면 대부분의 경우 Java 힙 메모리를 반환하지 않습니다.

이러한 동작은 리소스가 사용으로 지불되는 컨테이너 환경에서 특히 불리합니다. VM이 비활성 상태로 인해 할당된 메모리 리소스의 일부만 사용하는 단계에서도 G1은 모든 Java 힙을 유지합니다. 따라서 고객은 항상 모든 리소스에 대한 비용을 지불하고 클라우드 공급업체는 하드웨어를 완전히 활용할 수 없게 됩니다.

VM이 활용도가 낮은 Java 힙의 단계를 감지하고("유휴" 단계) 해당 기간 동안 해당 힙 사용량을 자동으로 줄일 수 있다면 둘 다 유용합니다.

Senandoah와 OpenJ9의 GenCon 수집기는 이미 유사한 기능을 제공합니다.

Bruno et al., 섹션 5.5의 프로토타입으로 테스트한 결과, 낮에는 HTTP 요청을 처리하고 밤에는 대부분 유휴 상태인 Tomcat 서버의 실제 활용률을 기준으로 이 솔루션을 사용하면 Java VM에서 커밋하는 메모리 양을 85% 줄일 수 있습니다.

#### 기술

최대 메모리 양을 운영 체제에 반환한다는 목표를 달성하기 위해 G1은 애플리케이션이 비활성 상태인 동안 주기적으로 동시 사이클을 계속하거나 트리거하여 전체 Java 힙 사용량을 결정합니다. 그러면 Java 힙의 사용되지 않은 부분이 자동으로 운영 체제로 되돌아갑니다. 선택적으로 사용자 제어 하에서 전체 GC를 수행하여 반환되는 메모리 양을 극대화할 수 있습니다.

응용 프로그램은 비활성 상태로 간주되며, G1은 다음 두 가지 경우 정기적으로 가비지 수집을 트리거합니다.

- 이전 가비지 수집 일시 중지 이후 G1PeriodicGCInterval 밀리세컨드가 초과되었으며 현재 진행 중인 동시 주기는 없습니다. 값이 0이면 메모리를 신속하게 회수하기 위한 정기적인 가비지 컬렉션이 비활성화되어 있음을 나타냅니다.
- JVM 호스트 시스템(예: 컨테이너)의 getloadavg() 호출에 의해 반환되는 평균 1분 시스템 로드 값이 G1PeriodicGCSystemLoadThreshold보다 낮습니다. G1PeriodicGCSystemLoadThreshold가 0이면 이 상태는 무시됩니다.

이러한 조건 중 하나가 충족되지 않으면 현재 예상 정기 가비지 수집이 취소됩니다. 다음에 G1PeriodicGCInterval 시간이 경과할 때 정기적인 가비지 컬렉션을 다시 고려합니다.

주기적 가비지 수집 유형은 G1PeriodicGCInvokesConcurrent 옵션의 값에 따라 결정됩니다. 이 옵션을 설정하면 G1은 전체 GC를 수행합니다. 두 컬렉션이 모두 끝나면 G1은 현재 Java 힙 크기를 조정하여 메모리를 작업 시스템으로 반환할 수 있습니다. 새 Java 힙 크기는 MinHeapFreeRatio, MaxHeapFreeRatio 및 최소 및 최대 힙 크기 구성을 포함하여 Java 힙 크기를 조정하기 위한 기존 구성에 의해 결정됩니다.

기본적으로 G1은 이 주기적 가비지 수집 중에 동시 주기를 시작하거나 계속합니다. 따라서 애플리케이션의 운영 중단이 최소화되지만 전체 수집과 비교할 때 결국 메모리 양이 그리 많지 않을 수 있습니다.

이 메커니즘에 의해 트리거된 가비지 컬렉션은 G1 주기적 컬렉션 원인과 함께 태그가 지정됩니다. 이러한 로그의 모양에 대한 예는 다음과 같습니다.

```powershell
(1) [6.084s][debug][gc,periodic ] Checking for periodic GC.
    [6.086s][info ][gc          ] GC(13) Pause Young (Concurrent Start) (G1 Periodic Collection) 37M->36M(78M) 1.786ms
(2) [9.087s][debug][gc,periodic ] Checking for periodic GC.
    [9.088s][info ][gc          ] GC(15) Pause Young (Prepare Mixed) (G1 Periodic Collection) 9M->9M(32M) 0.722ms
(3) [12.089s][debug][gc,periodic ] Checking for periodic GC.
    [12.091s][info ][gc          ] GC(16) Pause Young (Mixed) (G1 Periodic Collection) 9M->5M(32M) 1.776ms
(4) [15.092s][debug][gc,periodic ] Checking for periodic GC.
    [15.097s][info ][gc          ] GC(17) Pause Young (Mixed) (G1 Periodic Collection) 5M->1M(32M) 4.142ms
(5) [18.098s][debug][gc,periodic ] Checking for periodic GC.
    [18.100s][info ][gc          ] GC(18) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 1.685ms
(6) [21.101s][debug][gc,periodic ] Checking for periodic GC.
    [21.102s][info ][gc          ] GC(20) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 0.868ms
(7) [24.104s][debug][gc,periodic ] Checking for periodic GC.
    [24.104s][info ][gc          ] GC(22) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 0.778ms
```

위의 예에서 G1PeriodicGCInterval 3000ms로 실행되며, (1)단계에서 G1은 (동전 시작) 및 (G1 주기 수집)으로 표시되는 동시 사이클을 시작합니다. 이 동시 사이클은 처음에는 용량 번호(78M)와 용량 번호(32M)가 (1)에서 (2)로 감소하여 일부 메모리를 반환합니다. (2)에서 (4) 사이의 간격 동안 더 많은 주기적 컬렉션이 트리거되며, 이번에는 힙을 압축하기 위해 혼합 컬렉션을 트리거합니다. 다음 주기적 가비지 컬렉션(5 ~ 7)은 G1 정책에 따라 동시 주기가 시작되는데, 이때 이전 세대에는 혼합 GC 단계를 시작하기 위한 가비지가 충분하지 않다고 판단됩니다. 이 경우 최소 힙 크기에 이미 도달했기 때문에 (5) - (7) 주기적 가비지 컬렉션은 힙을 더 이상 축소하지 않습니다.

애플리케이션 비활성 동안(예: 소프트 참조 만료로 인해) 개체 사용량이 변경되면 해당 유휴 시간 동안 커밋된 Java 힙이 추가로 감소할 수 있습니다.

#### 대안

Jcmd 도구 또는 VM에 주입된 일부 코드와 같은 VM 외부에서 유사한 기능을 얻을 수 있습니다. 여기에는 숨겨진 비용이 있습니다. 즉, 노드에 있는 수백 또는 수천 개의 컨테이너의 경우, 크론 기반 작업을 사용하여 검사를 수행한다고 가정하면 이러한 컨테이너 중 많은 수가 동시에 힙 컴플라이언스 작업을 수행하여 호스트에서 CPU 스파이크를 매우 크게 발생시킬 수 있습니다.

다른 대안은 각 Java 프로세스에 자동으로 연결되는 Java 에이전트입니다. 그러면 용기가 서로 다른 시간에 시작될 때 검사 시간이 자연스럽게 배포되며, 새 프로세스를 시작하지 않기 때문에 CPU의 비용이 적게 듭니다. 그러나 이 방법은 사용자에게 상당한 복잡성을 가중시켜 채택을 방해할 수 있습니다.

Java 힙을 적시에 축소하는 특정 사용 사례는 VM에서 특별한 지원이 필요한 매우 일반적인 사용 사례로 간주됩니다.

#### 위험과 과정

구성의 기본값에서는 이 기능을 사용하지 않도록 설정합니다. 따라서 지연 시간 또는 처리량에 중요한 애플리케이션에 대한 VM 동작에 예기치 않은 변화가 없습니다. 이 기능을 사용할 경우 일반적으로 Java 힙 메모리를 운영 체제에 다시 제공하는 것이 바람직하며, 이로 인해 발생하는 동시 사이클 또는 연속성이 애플리케이션 처리량에 미치는 영향은 무시할 수 있습니다.

이 기능을 사용하도록 설정하면 VM은 다른 옵션과 관계없이 위의 조건에 따라 이러한 정기 컬렉션을 실행합니다. 예를 들어 사용자가 -Xms를 -Xmx 및 기타(결합) 옵션으로 설정하여 가비지 수집이 최소화되고 일관된 상태로 일시 중지되는 경우를 VM에서 가정할 수 있습니다. 일관성상의 이유로 인해 이러한 상황은 발생하지 않습니다.

정기적인 가비지 수집이 여전히 프로그램 실행을 방해할 경우, 전체 시스템 CPU 로드를 고려하거나 사용자가 정기 가비지 수집을 완전히 사용하지 않도록 설정할 수 있는 제어 기능을 제공합니다.



## 참고

- <https://www.oracle.com/technetwork/java/javase/12-relnote-issues-5211422.html#JDK-8209923>
- <http://openjdk.java.net/projects/jdk/12/>
- <http://www.itworld.co.kr/news/111430>
- <https://metebalci.com/blog/what-is-new-in-java-12/>
- <https://dzone.com/articles/java-12-string-api-updates>